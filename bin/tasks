#! /usr/bin/env node --harmony

'use strict';

// Dependencies
var co      = require('co');
var program = require('commander');
var colors  = require('colors');
var pkg     = require('../package');
var Tasks   = require('tasks-model');
var parse   = require('../lib/parser');
var tasks   = new Tasks();

program
  .version(pkg.version)
;

program
  .command('add [options...]')
  .description('add new task')
  .action(co(add))
;

program
  .command('update <id> [options...]')
  .description('update task by id')
  .action(co(update))
;

program
  .command('get [id|tag]')
  .description('get tasks by id or tag')
  .option('-c, --count', 'show only count')
  .action(co(get))
;

program
  .command('done <id...>')
  .description('mark task as finished')
  .action(co(done))
;

// program
//   .command('* <id> [options...]')
//   .action(co(function * (id, options) {
//     console.log(id, options);
//     yield program.args.length
//       ? co(add())
//       : co(next())
//     , process.exit(0);
//   }))
// ;

program.parse(process.argv);

  // .command('add [options...]', 'add new task', co(add))
  // .option('-u, --update <id> [task-option:value]', 'prompt update name and description', co(update))
  // .option('-d, --delete <id>', 'delete task by id', remove)
  // .option('-g, --get <id or tag>', 'find tasks by ID or TAG', get)
  // .option('-f, --find <key>', 'find tasks by keywords', find)
  // .option('-n, --next', 'show next tasks', next)
  // // .action(co(action))
  // .parse(process.argv)
// ;


// if no options selected
// function * action () {
//   yield program.args.length
//     ? add()
//     : next()
//   , process.exit(0);
// }

// update task by id
function * add (options) {
  var data = parse(options.join(' '));
  data.tags = data.tags
    ? sliceTags(data.tags)
    : ['inbox'];
  var task = yield tasks.add(data);
  print(task[0]);
  process.exit(0);
}

// update task by id
function * update (id) {
  id = parseInt(trimHash(id));
  var query = process.argv.slice(2).join(' ');
  var data = parse(query);
  data.tags && (data.tags = sliceTags(data.tags));
  yield tasks.update(parseInt(id), data);
  var task = yield tasks.get(id);
  print(task);
  process.exit(0);
}

// delete task by id
function remove () {
  console.log('remove');
  process.exit(0);
}

// get tasks by id or key
function * get (id, options) {
  if (id) {
    id = trimHash(id);
    id = id == parseInt(id) ? parseInt(id) : id; // TODO: stupid
  }
  var list = [].concat(yield tasks.get(id)); // always is array! :D
  options.count
    ? console.log(list.length)
    : print(list);
  process.exit(0);
}

// mark task al finished
function * done (ids) {
  ids = [].concat(ids);
  var thunks = ids.map(function(id) {
    id = parseInt(trimHash(id));
    return function * () {
      console.log('done #' + id.toString().blue);
      yield tasks.done(id);
    };
  });
  yield thunks;
  process.exit(0);
}

// find task by keywords
function find () {
  console.log('find');
  process.exit(0);
}

// list of the next tasks
function next () {
  console.log('next');
  process.exit(0);
}

// print task
// TODO: make it super awesome
function print (task) {
  if (Array.isArray(task)) { return task.map(print); }
  console.log();
  var str = ['#'+task._id.toString().blue, task.name.black].join(' ');
  console.log(str);
  task.description && console.log(task.description);
  task.tags && console.log('tags: ', task.tags.reduce(function(m, tag) {
    return m.push('#' + tag.red), m;
  }, []).join(', '));
  console.log();
}

function sliceTags (tags) {
  return tags.split(',').map(function (tag) {
    return tag.trim(); 
  });
}

function trimHash(str) {
  return str.replace(/^#/, '');
}
